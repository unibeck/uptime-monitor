// Basic structure for API route tests
// We'll need to mock dependencies like Drizzle, getCloudflareContext, etc.
// and use a library like vitest with supertest or hono/testing.

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { Hono } from 'hono';
import { testClient } from 'hono/testing';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { GET, POST } from './route'; // Import the route handlers
import { useDrizzle, takeUniqueOrThrow } from '@/db';
import { getCloudflareContext } from '@opennextjs/cloudflare';
import { CREATED, OK, BAD_REQUEST, CONFLICT } from 'stoker/http-status-codes';
import { PRE_ID } from '@/lib/ids';

// Mock dependencies
vi.mock('@/db', async (importOriginal) => {
  const actual = await importOriginal() as typeof import('@/db');
  return {
    ...actual,
    useDrizzle: vi.fn(),
    takeUniqueOrThrow: vi.fn(items => {
      if (!items || items.length === 0) throw new Error("No items found or an empty array was passed.");
      return items[0];
    }),
  };
});

vi.mock('@opennextjs/cloudflare', () => ({
  getCloudflareContext: vi.fn(),
}));

// Mock createId to return a predictable ID
vi.mock('@/lib/ids', async (importOriginal) => {
 const actual = await importOriginal() as typeof import('@/lib/ids');
 return {
    ...actual,
    createId: vi.fn((prefix: PRE_ID) => `${prefix}_test123`),
 };
});


describe('API: /api/email-notification-channels', () => {
  let app: Hono;
  let mockDb: any;

  beforeEach(() => {
    // Setup Hono app with mocked context for each test
    app = new Hono();
    app.get('/api/email-notification-channels', GET.fetch);
    app.post('/api/email-notification-channels', POST.fetch);


    mockDb = {
      select: vi.fn().mockReturnThis(),
      from: vi.fn().mockReturnThis(),
      where: vi.fn().mockReturnThis(),
      limit: vi.fn().mockReturnThis(),
      insert: vi.fn().mockReturnThis(),
      values: vi.fn().mockReturnThis(),
      returning: vi.fn().mockResolvedValue([]), // Default to empty array for returning
      leftJoin: vi.fn().mockReturnThis(),
      orderBy: vi.fn().mockReturnThis(),
      offset: vi.fn().mockReturnThis(),
      groupBy: vi.fn().mockReturnThis(),
      as: vi.fn().mockReturnThis(), // For subqueries
    };
    (useDrizzle as vi.Mock).mockReturnValue(mockDb);
    (getCloudflareContext as vi.Mock).mockReturnValue({ env: { DB: {} } }); // Mock CF context
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('POST /api/email-notification-channels', () => {
    const validChannelData = { name: 'Test Channel', emailAddress: 'test@example.com' };
    const createdChannel = { 
        id: `${PRE_ID.emailNotificationChannel}_test123`, 
        ...validChannelData, 
        createdAt: new Date().toISOString(), // Approximate, actual value comes from DB/defaultFn
        updatedAt: new Date().toISOString(), 
    };

    it('should create a new email notification channel successfully (201)', async () => {
      mockDb.limit.mockResolvedValueOnce([]); // For checking existing channel (none found)
      // Mock the insert().values().returning() chain
      const mockInsertReturning = vi.fn().mockResolvedValue([createdChannel]);
      const mockInsertValues = vi.fn().mockReturnValue({ returning: mockInsertReturning });
      mockDb.insert.mockReturnValue({ values: mockInsertValues });


      const client = testClient(app);
      const response = await client['api']['email-notification-channels'].$post({ json: validChannelData });

      expect(response.status).toBe(CREATED);
      const responseBody = await response.json();
      expect(responseBody).toMatchObject({ 
        id: createdChannel.id,
        name: validChannelData.name,
        emailAddress: validChannelData.emailAddress,
      });
      expect(mockDb.insert).toHaveBeenCalledWith(expect.anything()); // Check if EmailNotificationChannelsTable was passed
      expect(mockInsertValues).toHaveBeenCalledWith(validChannelData); // ID is generated by $defaultFn
    });

    it('should return 400 for invalid request body (missing name)', async () => {
      const client = testClient(app);
      const response = await client['api']['email-notification-channels'].$post({ json: { emailAddress: 'test@example.com' } as any });
      expect(response.status).toBe(BAD_REQUEST);
    });

    it('should return 400 for invalid email format', async () => {
        const client = testClient(app);
        const response = await client['api']['email-notification-channels'].$post({ json: { name: 'Test', emailAddress: 'invalid-email' } });
        expect(response.status).toBe(BAD_REQUEST);
    });
    
    it('should return 409 if email address already exists', async () => {
      mockDb.limit.mockResolvedValueOnce([{ id: 'enc_existing', ...validChannelData }]); // Simulate email exists

      const client = testClient(app);
      const response = await client['api']['email-notification-channels'].$post({ json: validChannelData });

      expect(response.status).toBe(CONFLICT);
      const responseBody = await response.json();
      expect(responseBody.message).toContain('already exists');
    });
  });

  describe('GET /api/email-notification-channels', () => {
    const mockChannels = [
        { id: 'enc_1', name: 'Channel 1', emailAddress: 'c1@example.com', createdAt: new Date(), updatedAt: new Date(), monitorCount: 2 },
        { id: 'enc_2', name: 'Channel 2', emailAddress: 'c2@example.com', createdAt: new Date(), updatedAt: new Date(), monitorCount: 0 },
    ];

    it('should return a list of email notification channels (200)', async () => {
      // Mock for the main query
      mockDb.offset.mockResolvedValueOnce(mockChannels);
      // Mock for the totalCount query
      (takeUniqueOrThrow as vi.Mock).mockResolvedValueOnce({ count: mockChannels.length });
      // Mock for the subquery (monitorCount) - this is tricky as it's a subquery.
      // For simplicity, assume the main query mock already includes monitorCount or adjust if direct subquery mocking is needed.
      // If the subquery is complex, it might need its own mock setup. The current structure of the query
      // means the `leftJoin` and `select` on the main table incorporate the subquery logic.
      // So, `mockDb.offset.mockResolvedValueOnce(mockChannels)` should be enough if `mockChannels` has `monitorCount`.

      const client = testClient(app);
      const response = await client['api']['email-notification-channels'].$get({ query: { page: '0', pageSize: '10' } });
      
      expect(response.status).toBe(OK);
      const responseBody = await response.json();
      expect(responseBody.data).toHaveLength(mockChannels.length);
      expect(responseBody.data[0]).toMatchObject({ name: 'Channel 1', monitorCount: 2 });
      expect(responseBody.totalCount).toBe(mockChannels.length);
    });

    it.todo('should correctly calculate and return monitorCount for each channel (covered by above if data includes it)');
    
    it('should support pagination', async () => {
        mockDb.offset.mockResolvedValueOnce([mockChannels[0]]); // Return one item for page 1
        (takeUniqueOrThrow as vi.Mock).mockResolvedValueOnce({ count: mockChannels.length });

        const client = testClient(app);
        const response = await client['api']['email-notification-channels'].$get({ query: { page: '0', pageSize: '1' } });

        expect(response.status).toBe(OK);
        const responseBody = await response.json();
        expect(responseBody.data).toHaveLength(1);
        expect(responseBody.data[0].name).toBe(mockChannels[0].name);
        expect(responseBody.totalCount).toBe(mockChannels.length);
        expect(mockDb.limit).toHaveBeenCalledWith(1); // pageSize
        expect(mockDb.offset).toHaveBeenCalledWith(0); // pageIndex * pageSize
    });
    
    it('should support search by name', async () => {
        const searchTerm = 'Channel 1';
        const filteredChannels = mockChannels.filter(c => c.name.includes(searchTerm));
        mockDb.offset.mockResolvedValueOnce(filteredChannels);
        (takeUniqueOrThrow as vi.Mock).mockResolvedValueOnce({ count: filteredChannels.length });

        const client = testClient(app);
        const response = await client['api']['email-notification-channels'].$get({ query: { search: searchTerm, page: '0', pageSize: '10' } });

        expect(response.status).toBe(OK);
        const responseBody = await response.json();
        expect(responseBody.data).toHaveLength(filteredChannels.length);
        expect(responseBody.data[0].name).toBe(searchTerm);
        // Check if `where` was called with a condition involving the search term
        expect(mockDb.where).toHaveBeenCalledWith(expect.objectContaining({ _sqlParts: expect.arrayContaining([expect.stringContaining(`%${searchTerm}%`)]) }));
    });

    it('should support sorting by name ascending', async () => {
        const sortedChannels = [...mockChannels].sort((a, b) => a.name.localeCompare(b.name));
        mockDb.offset.mockResolvedValueOnce(sortedChannels);
        (takeUniqueOrThrow as vi.Mock).mockResolvedValueOnce({ count: sortedChannels.length });

        const client = testClient(app);
        const response = await client['api']['email-notification-channels'].$get({ query: { orderBy: 'name', order: 'asc', page: '0', pageSize: '10' } });
        
        expect(response.status).toBe(OK);
        const responseBody = await response.json();
        expect(responseBody.data.map((d:any) => d.name)).toEqual(sortedChannels.map(c => c.name));
        // Check if `orderBy` was called correctly
        expect(mockDb.orderBy).toHaveBeenCalledWith(expect.anything(), expect.anything()); // More specific check might be needed for the exact column and direction
    });
  });
});
