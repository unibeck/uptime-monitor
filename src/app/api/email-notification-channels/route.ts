import { getCloudflareContext } from "@opennextjs/cloudflare";
import { and, asc, count, desc, eq, like, sql } from "drizzle-orm";
import type { SQLiteColumn } from "drizzle-orm/sqlite-core";
import { NextResponse } from "next/server";
import { z } from "zod";

import { takeUniqueOrThrow, useDrizzle } from "@/db";
import {
  EmailNotificationChannelsTable,
  EndpointMonitorEmailChannelsTable,
} from "@/db/schema";
import {
  emailNotificationChannelInsertSchema,
  emailNotificationChannelSelectSchema,
} from "@/db/zod-schema";
import { createRoute } from "@/lib/api-utils";
import { paginationQuerySchema } from "@/lib/route-schemas";

/**
 * GET /api/email-notification-channels
 *
 * Retrieves a paginated list of email notification channels with ordering options and monitor count.
 */
const extendedQuerySchema = paginationQuerySchema().extend({
  search: z.string().optional(),
});

export const GET = createRoute
  .query(extendedQuerySchema)
  .handler(async (_request, context) => {
    const { env } = getCloudflareContext();
    const db = useDrizzle(env.DB);

    const {
      pageSize,
      page,
      orderBy: orderByParam,
      order: orderParam,
      search,
    } = context.query;

    const orderBy = orderByParam ?? "name";
    const order = orderParam ?? "asc";

    const orderByCol = getColumn(
      orderBy,
      EmailNotificationChannelsTable
    ) as SQLiteColumn; // Cast to avoid type issues with mixed tables
    const orderDir = getOrderDirection(order as "asc" | "desc");

    const whereConditions = and(
      search
        ? sql`(${like(
            EmailNotificationChannelsTable.name,
            `%${search}%`
          )} OR ${like(
            EmailNotificationChannelsTable.emailAddress,
            `%${search}%`
          )})`
        : sql`1=1`
    );

    const channelsSubquery = db
      .select({
        id: EndpointMonitorEmailChannelsTable.emailChannelId,
        monitorCount: count(
          EndpointMonitorEmailChannelsTable.endpointMonitorId
        ).as("monitorCount"),
      })
      .from(EndpointMonitorEmailChannelsTable)
      .groupBy(EndpointMonitorEmailChannelsTable.emailChannelId)
      .as("channelsSubquery");

    const emailChannels = await db
      .select({
        ...EmailNotificationChannelsTable,
        monitorCount: sql<number>`COALESCE(${channelsSubquery.monitorCount}, 0)`,
      })
      .from(EmailNotificationChannelsTable)
      .leftJoin(
        channelsSubquery,
        eq(EmailNotificationChannelsTable.id, channelsSubquery.id)
      )
      .where(whereConditions)
      .orderBy(orderDir(orderByCol), asc(EmailNotificationChannelsTable.id))
      .limit(pageSize)
      .offset(page * pageSize);

    const { count: totalCount } = await db
      .select({ count: count() })
      .from(EmailNotificationChannelsTable)
      .where(whereConditions)
      .then(takeUniqueOrThrow);

    return NextResponse.json({
      data: emailChannels,
      totalCount,
    });
  });

/**
 * POST /api/email-notification-channels
 *
 * Creates a new email notification channel.
 */
export const POST = createRoute
  .body(emailNotificationChannelInsertSchema)
  .handler(async (_request, context) => {
    const channelData = context.body;
    const { env } = getCloudflareContext();
    const db = useDrizzle(env.DB);

    // Check for existing email address
    const existingChannel = await db
      .select()
      .from(EmailNotificationChannelsTable)
      .where(eq(EmailNotificationChannelsTable.emailAddress, channelData.emailAddress))
      .limit(1);

    if (existingChannel.length > 0) {
      return NextResponse.json(
        {
          message: `An email notification channel with the email address "${channelData.emailAddress}" already exists.`,
          existingChannel: existingChannel[0],
        },
        { status: 409 } // Conflict
      );
    }

    const newChannel = await db
      .insert(EmailNotificationChannelsTable)
      .values(channelData) // ID is generated by $defaultFn
      .returning()
      .then(takeUniqueOrThrow);

    console.log("Created new email notification channel:", newChannel);
    return NextResponse.json(newChannel, { status: 201 });
  });

// Helper functions (similar to endpoint-monitors route)
function getOrderDirection(direction: "asc" | "desc") {
  return direction === "desc" ? desc : asc;
}

function getColumn(columnName: string, table: any): SQLiteColumn {
  return table[columnName as keyof typeof table] as SQLiteColumn;
}
